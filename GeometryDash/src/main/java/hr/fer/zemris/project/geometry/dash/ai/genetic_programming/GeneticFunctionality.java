package hr.fer.zemris.project.geometry.dash.ai.genetic_programming;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

import hr.fer.zemris.project.geometry.dash.ai.AIConstants;
import hr.fer.zemris.project.geometry.dash.model.GameEngine;
import hr.fer.zemris.project.geometry.dash.model.PlayingMode;
import hr.fer.zemris.project.geometry.dash.model.drawables.player.Player;
import hr.fer.zemris.project.geometry.dash.model.math.Vector2D;
import hr.fer.zemris.project.geometry.dash.model.settings.GameConstants;

/**
 * Implementation of customable genetic algorithm
 * 
 * @author Andi Å krgat
 *
 */
public class GeneticFunctionality {

	/**
	 * Random reference
	 */
	private Random random;

	/**
	 * Current population
	 */
	private List<Tree> currPopulation;

	/**
	 * By default we use three tournament selection
	 */
	private SelectionProcess selProcess = SelectionProcess.THREE_TOURNAMENT_SELECTION;

	/**
	 * By default we use eliminative genetic algorithm
	 */
	private GenAlg genAlg = GenAlg.ELIMINATIVE_GENETIC_ALGORITHM;

	/**
	 * Current inputs for genetic algorithm
	 */
	private List<Double> inputs = null;

	/**
	 * Sum of all goodness values in population
	 */
	private double population_goodness_value = -1;

	/**
	 * Worst in population
	 */
	private double worst_goodness_value_in_population = Double.MAX_VALUE;

	/**
	 * Locking object
	 */
	private Object lockingObject;

	/**
	 * Best of all trees
	 */
	private Tree elitisticTree = null;

	/**
	 * Initial depth of tree
	 */
	private int initialDepth = 6;

	/**
	 * Maximum depth of tree
	 */
	private int maxTreeDepth = 17;

	/**
	 * Should be okay
	 */
	private int treePopulationSize;

	/**
	 * We have
	 * <code>initialDepth<code> levels(2 to <code>initialDepth<code>) and <code>treePopulationSize</code>
	 * divided by <code>initialDepth</code> is populationSizeOfEachDepth
	 */
	private int populationSizeOfEachDepth;
	
	/**
	 * We have same number of trees generated by full and grow method
	 */
	private int populationSizeFullGrow;

	/**
	 * Default constructor
	 */
	public GeneticFunctionality() {
		random = new Random();
		currPopulation = new ArrayList<Tree>();
		inputs = Arrays.asList(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	}

	public GeneticFunctionality(int treePopulationSize, String selectionProcess, String geneticAlgorithm) {
		this();
		this.treePopulationSize = treePopulationSize;
		this.populationSizeOfEachDepth = treePopulationSize / (initialDepth - 1);
		populationSizeFullGrow = populationSizeOfEachDepth / 2;
		if(selectionProcess.equals("THREE_TOURNAMNET_SELECTION")) {
			this.selProcess = SelectionProcess.THREE_TOURNAMENT_SELECTION;
		} else if(selectionProcess.equals("ROULETTE_WHEEL_SELECTION")) {
			this.selProcess = SelectionProcess.ROULETTE_WHEEL_SELECTION;
		} else {
			throw new IllegalArgumentException("Unknown selection process!");
		}
		if(geneticAlgorithm.equals("ELIMINATIVE_GENETIC_ALGORITHM")) {
			this.genAlg = GenAlg.ELIMINATIVE_GENETIC_ALGORITHM;
		} else if(geneticAlgorithm.equals("GENERATIONAL_GENETIC_ALGORITHM")) {
			this.genAlg = GenAlg.GENERATIONAL_GENETIC_ALGORITHM;
		} else {
			throw new IllegalArgumentException("Unknown genetic algorithm!");
		}

	}

	/**
	 * @return the lockingObject
	 */
	public Object getLockingObject() {
		return lockingObject;
	}

	/**
	 * @param lockingObject the lockingObject to set
	 */
	public void setLockingObject(Object lockingObject) {
		this.lockingObject = lockingObject;
	}

	/**
	 * @return the elitisticTree
	 */
	public Tree getElitisticTree() {
		return elitisticTree;
	}

	/**
	 * @param elitisticTree the elitisticTree to set
	 */
	public void setElitisticTree(Tree elitisticTree) {
		this.elitisticTree = elitisticTree;
	}
	
	/**
	 * @return the population_goodness_value
	 */
	public double getPopulation_goodness_value() {
		return population_goodness_value;
	}

	/**
	 * @param population_goodness_value the population_goodness_value to set
	 */
	public void setPopulation_goodness_value(double population_goodness_value) {
		this.population_goodness_value = population_goodness_value;
	}

	/**
	 * @return the worst_goodness_value_in_population
	 */
	public double getWorst_goodness_value_in_population() {
		return worst_goodness_value_in_population;
	}

	/**
	 * @param worst_goodness_value_in_population the worst_goodness_value_in_population to set
	 */
	public void setWorst_goodness_value_in_population(double worst_goodness_value_in_population) {
		this.worst_goodness_value_in_population = worst_goodness_value_in_population;
	}

	/**
	 * @return the initialDepth
	 */
	public int getInitialDepth() {
		return initialDepth;
	}

	/**
	 * @param initialDepth the initialDepth to set
	 */
	public void setInitialDepth(int initialDepth) {
		this.initialDepth = initialDepth;
	}

	/**
	 * @return the maxTreeDepth
	 */
	public int getMaxTreeDepth() {
		return maxTreeDepth;
	}

	/**
	 * @param maxTreeDepth the maxTreeDepth to set
	 */
	public void setMaxTreeDepth(int maxTreeDepth) {
		this.maxTreeDepth = maxTreeDepth;
	}

	/**
	 * @return the treePopulationSize
	 */
	public int getTreePopulationSize() {
		return treePopulationSize;
	}

	/**
	 * @param treePopulationSize the treePopulationSize to set
	 */
	public void setTreePopulationSize(int treePopulationSize) {
		this.treePopulationSize = treePopulationSize;
	}

	/**
	 * @return the populationSizeOfEachDepth
	 */
	public int getPopulationSizeOfEachDepth() {
		return populationSizeOfEachDepth;
	}

	/**
	 * @param populationSizeOfEachDepth the populationSizeOfEachDepth to set
	 */
	public void setPopulationSizeOfEachDepth(int populationSizeOfEachDepth) {
		this.populationSizeOfEachDepth = populationSizeOfEachDepth;
	}

	/**
	 * @return the populationSizeFullGrow
	 */
	public int getPopulationSizeFullGrow() {
		return populationSizeFullGrow;
	}

	/**
	 * @param populationSizeFullGrow the populationSizeFullGrow to set
	 */
	public void setPopulationSizeFullGrow(int populationSizeFullGrow) {
		this.populationSizeFullGrow = populationSizeFullGrow;
	}

	/**
	 * Genetic algorithm
	 */
	public void performAlgorithm() {
		loop();
	}

	/**
	 * We initialize population of size {@linkplain AIConstants}.treePopulationSize
	 * using RHH method. With this method we create same number of trees for every
	 * tree size between 2 and {@linkplain AIConstants}.initialDepth. Half of these
	 * trees are generated with full method and half with grow method
	 */
	public void initializePopulation() {
		for (int i = 2; i <= initialDepth; i++) { // generate for each level
			for (int j = 1; j <= 2; j++) { // first generate trees by full method, then by grow method
				for (int k = 1; k <= populationSizeFullGrow; k++) { // half goes for grow, half goes for
					TreeNode root = new TreeNode(new Action(TreeUtil.numberToActionType(random.nextInt(25) + 1)));
					if (j == 1) { // generate full tree
						TreeUtil.randomSubtree(root, i - 1, random, inputs, true);
					} else { // if tree is generated with grow method
						TreeUtil.randomSubtree(root, i - 1, random, inputs, false);
					}
					Tree tree = new Tree(root);
					Player player = new Player(
							new Vector2D(0, GameConstants.floorPosition_Y - GameConstants.iconHeight - 5),
							new Vector2D(GameConstants.playerSpeed_X, GameConstants.playerSpeed_Y),
							PlayingMode.NEURAL_NETWORK);
					tree.setPlayer(player);
					currPopulation.add(tree);
				}
			}
		}
	}

	/**
	 * Create algorithm
	 */
	private void loop() {
		if (genAlg == GenAlg.ELIMINATIVE_GENETIC_ALGORITHM) {
			for (int i = 0; i < AIConstants.maxGenerations; i++) {
				population_goodness_value = 0;
				GameEngine.getInstance().getGameWorld().setUnlockingCondition(false);
				GameEngine.getInstance().getGameWorld().setLevelPassed(false);
				worst_goodness_value_in_population = Double.MAX_VALUE;

				double almost_min = Double.MAX_VALUE;
				double max = Double.MIN_VALUE;
				Tree minTree = null;
				Tree almostMinTree = null;
				Tree maxTree = null;

				synchronized (lockingObject) {
					while (!GameEngine.getInstance().getGameWorld().isUnlockingCondition()) {
						try {
							lockingObject.wait();
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
				}
				System.out.println("Door unlocked!");
				for (int j = 0; j < treePopulationSize; j++) {
					Tree currentTree = currPopulation.get(j);
					double value = currentTree.getPlayer().getGoodness_value();
					population_goodness_value += value;
					if (value < worst_goodness_value_in_population) {
						almost_min = worst_goodness_value_in_population;
						worst_goodness_value_in_population = value;
						almostMinTree = minTree;
						minTree = currentTree;
					} else if (value < almost_min) {
						almost_min = value;
						almostMinTree = currentTree;
					} else if (value > max) {
						max = value;
						maxTree = currentTree;
					}
				}
				System.out.println("Sadrzava min tree " + currPopulation.contains(minTree));
				currPopulation.remove(minTree);
				System.out.println("Sadrzava almost min tree " + currPopulation.contains(almostMinTree));
				currPopulation.remove(almostMinTree);

				if (elitisticTree == null
						|| maxTree.getPlayer().getGoodness_value() > elitisticTree.getPlayer().getGoodness_value()) {
					elitisticTree = maxTree;
				}
				List<Tree> selectedTrees = selection();
				int firstTree = random.nextInt(selectedTrees.get(0).getSize()) + 1;
				int secondTree = random.nextInt(selectedTrees.get(1).getSize()) + 1;
				List<Tree> crossovered = TreeUtil.crossover(selectedTrees.get(0), selectedTrees.get(1), firstTree,
						secondTree);
				int targetNode1 = random.nextInt(crossovered.get(0).getSize()) + 1;
				Tree mutated1 = TreeUtil.mutate(crossovered.get(0), targetNode1, random, inputs);
				int targetNode2 = random.nextInt(crossovered.get(1).getSize()) + 1;
				Tree mutated2 = TreeUtil.mutate(crossovered.get(1), targetNode2, random, inputs);
				currPopulation.add(mutated1);
				currPopulation.add(mutated2);
			}
		} else if (genAlg == GenAlg.GENERATIONAL_GENETIC_ALGORITHM) {
			int genNumber = 0;
			while (genNumber < AIConstants.maxGenerations) {
				GameEngine.getInstance().getGameWorld().setUnlockingCondition(false);
				GameEngine.getInstance().getGameWorld().setLevelPassed(false);
				worst_goodness_value_in_population = Double.MAX_VALUE;
				synchronized (lockingObject) {
					while (!GameEngine.getInstance().getGameWorld().isUnlockingCondition()) {
						try {
							lockingObject.wait();
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
				}
				Tree bestTree = null;
				Tree almostBestTree = null;
				double max = Double.MIN_VALUE;
				double almostMax = Double.MIN_VALUE;

				for (int j = 0; j < treePopulationSize; j++) {
					Tree currentTree = currPopulation.get(j);
					double value = currentTree.getPlayer().getGoodness_value();
					if (value > max) {
						almostMax = max;
						almostBestTree = bestTree;
						max = value;
						bestTree = currentTree;
					} else if (value > almostMax) {
						almostMax = value;
						almostBestTree = currentTree;
					}
				}
				System.out.println("Generacijski algoritam, postoji li najbolji u populaciji "
						+ currPopulation.contains(bestTree));
				System.out.println("Generacijski algoritam, postoji li skoro najbolji u populaciji "
						+ currPopulation.contains(almostBestTree));
				List<Tree> newGeneration = new ArrayList<Tree>();
				newGeneration.add(bestTree);
				newGeneration.add(almostBestTree);
				if (elitisticTree == null
						|| bestTree.getPlayer().getGoodness_value() > elitisticTree.getPlayer().getGoodness_value()) {
					elitisticTree = bestTree;
				}
				// dodaj ih u game world
				// pokreni
				// ovo je training mode
				// cekaj da zavrse
				// zapamti 2 najbolja
				// dodaj ih u newGeneration
				while (newGeneration.size() < treePopulationSize) {
					List<Tree> selectedTrees = selection();
					int firstTree = random.nextInt(selectedTrees.get(0).getSize()) + 1;
					// dok su isti stvaraj second tree
					int secondTree = random.nextInt(selectedTrees.get(1).getSize()) + 1;
					List<Tree> crossovered = TreeUtil.crossover(selectedTrees.get(0), selectedTrees.get(1), firstTree,
							secondTree);
					int targetNode1 = random.nextInt(crossovered.get(0).getSize()) + 1;
					Tree mutated1 = TreeUtil.mutate(crossovered.get(0), targetNode1, random, inputs);
					int targetNode2 = random.nextInt(crossovered.get(1).getSize()) + 1;
					Tree mutated2 = TreeUtil.mutate(crossovered.get(1), targetNode2, random, inputs);
					newGeneration.add(mutated1);
					newGeneration.add(mutated2);
				}
				currPopulation = newGeneration;
				genNumber++;
			}
		}
	}

	/**
	 * Selection algorithm
	 * 
	 * @return list of selected trees
	 */
	private List<Tree> selection() {
		List<Tree> list = new ArrayList<Tree>();
		if (selProcess == SelectionProcess.THREE_TOURNAMENT_SELECTION) {
			int[] indexes = random.ints(0, treePopulationSize).distinct().limit(3).toArray();
			list.add(currPopulation.get(indexes[0]));
			list.add(currPopulation.get(indexes[1]));
			list.add(currPopulation.get(indexes[2]));
			if (list.get(0).getPlayer().getGoodness_value() < list.get(1).getPlayer().getGoodness_value()
					&& list.get(0).getPlayer().getGoodness_value() < list.get(2).getPlayer().getGoodness_value()) {
				list.remove(0);
			} else if (list.get(1).getPlayer().getGoodness_value() < list.get(0).getPlayer().getGoodness_value()
					&& list.get(1).getPlayer().getGoodness_value() < list.get(2).getPlayer().getGoodness_value()) {
				list.remove(1);
			} else {
				list.remove(2);
			}
		} else if (selProcess == SelectionProcess.ROULETTE_WHEEL_SELECTION) {
			Tree tree1 = getPlayerByRoulette();
			if (tree1 == null) { // uniformly select
				tree1 = currPopulation.get(random.nextInt(treePopulationSize));
			}
			Tree tree2 = getPlayerByRoulette();
			if (tree2 == null) {
				tree2 = currPopulation.get(random.nextInt(treePopulationSize));
			}
			list.add(tree1);
			list.add(tree2);
		}
		return list;
	}

	/**
	 * @return tree using roulette algorithm in which better individual has more
	 *         chances to be selected
	 * 
	 */
	private Tree getPlayerByRoulette() {
		double d = random.nextDouble() * (1 - population_goodness_value * treePopulationSize);
		if (d < 0) {
			throw new IllegalArgumentException("Something is wrong with roulette_wheel selection");
		}
		double curr = 0;
		for (int i = 0; i < treePopulationSize; i++) {
			if (curr + (currPopulation.get(i).getPlayer().getGoodness_value() - worst_goodness_value_in_population)
					/ population_goodness_value > d) {
				return currPopulation.get(i);
			}
			curr += (currPopulation.get(i).getPlayer().getGoodness_value() - worst_goodness_value_in_population);
		}
		return null;
	}

	/**
	 * @return the random
	 */
	public Random getRandom() {
		return random;
	}

	/**
	 * @param random the random to set
	 */
	public void setRandom(Random random) {
		this.random = random;
	}

	/**
	 * @return the currPopulation
	 */
	public List<Tree> getCurrPopulation() {
		return currPopulation;
	}

	/**
	 * @param currPopulation the currPopulation to set
	 */
	public void setCurrPopulation(List<Tree> currPopulation) {
		this.currPopulation = currPopulation;
	}

	/**
	 * @return the inputs
	 */
	public List<Double> getInputs() {
		return inputs;
	}

	/**
	 * @param inputs the inputs to set
	 */
	public void setInputs(List<Double> inputs) {
		this.inputs = inputs;
	}

	/**
	 * @return the selProcess
	 */
	public SelectionProcess getSelProcess() {
		return selProcess;
	}

	/**
	 * @param selProcess the selProcess to set
	 */
	public void setSelProcess(SelectionProcess selProcess) {
		this.selProcess = selProcess;
	}

	/**
	 * @return the genAlg
	 */
	public GenAlg getGenAlg() {
		return genAlg;
	}

	/**
	 * @param genAlg the genAlg to set
	 */
	public void setGenAlg(GenAlg genAlg) {
		this.genAlg = genAlg;
	}
}
